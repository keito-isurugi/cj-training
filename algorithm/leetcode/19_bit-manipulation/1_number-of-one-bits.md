# Number of 1 Bits (Easy)

## 問題内容

符号なし整数 `n` が与えられる。その2進数表現における `1` のビット数（ハミング重み）を返す。

`n` は32ビットに収まる非負整数と仮定してよい。

### 例

```
Input: n = 00000000000000000000000000010111

Output: 4
```

```
Input: n = 01111111111111111111111111111101

Output: 30
```

### 制約

- 入力は32ビット符号なし整数

## ソースコード

```go
func hammingWeight(n int) int {
    res := 0
    for n != 0 {
        n &= n - 1
        res++
    }
    return res
}
```

## アルゴリズムなど解説

### 基本戦略（Brian Kernighan のアルゴリズム）

**重要な観察**: `n & (n - 1)` は **最も右にある1ビットを消去** する

```
n     = 10110100
n-1   = 10110011
n&(n-1) = 10110000  ← 最右の1が消えた
```

この操作を `n` が `0` になるまで繰り返し、操作回数をカウント。

### 動作の仕組み

```go
func hammingWeight(n int) int {
    res := 0
    for n != 0 {
        n &= n - 1  // 最右の1ビットを消去
        res++       // カウント増加
    }
    return res
}
```

### 具体例

```
n = 21 (10101)

n = 10101 (21)
n & (n-1) = 10101 & 10100 = 10100, res = 1

n = 10100 (20)
n & (n-1) = 10100 & 10011 = 10000, res = 2

n = 10000 (16)
n & (n-1) = 10000 & 01111 = 00000, res = 3

結果: 3
```

### なぜ n & (n-1) が最右の1を消すか

`n - 1` の操作：
1. 最右の1を0に変える
2. その右のすべてのビットを1に変える

ANDを取ると：
- 最右の1より左は変化なし
- 最右の1は0になる
- 右側はすべて0になる

### 計算量

| 計算量 | 値 | 説明 |
|--------|-----|------|
| 時間計算量 | O(1) | 最大32回のループ |
| 空間計算量 | O(1) | 定数空間 |

実際のループ回数は1ビットの数に等しいため、0が多い数ほど高速。

### 別解1：ビットマスク

```go
func hammingWeight(n int) int {
    res := 0
    for i := 0; i < 32; i++ {
        if (1<<i)&n != 0 {
            res++
        }
    }
    return res
}
```

各ビット位置をチェック。常に32回ループ。

### 別解2：右シフト

```go
func hammingWeight(n int) int {
    res := 0
    for n != 0 {
        if n&1 != 0 {
            res++
        }
        n >>= 1
    }
    return res
}
```

最下位ビットをチェックしながら右にシフト。

### 3つの解法の比較

| 解法 | 時間計算量 | ループ回数 | 特徴 |
|------|------------|------------|------|
| Brian Kernighan | O(1) | 1ビットの数 | 最速 |
| ビットマスク | O(1) | 32回 | シンプル |
| 右シフト | O(1) | log(n)回 | 直感的 |

### Bit Manipulation パターン

この問題は **ポップカウント** パターン：
- `n & (n-1)` で最右の1を消去
- ハミング重みの計算
- ビット演算の基本

### 関連問題との比較

| 問題 | パターン |
|------|---------|
| **Number of 1 Bits** | ハミング重み |
| Counting Bits | 0〜nの各ハミング重み |
| Reverse Bits | ビット反転 |
| Power of Two | 1ビットかどうか |

### 応用

`n & (n-1) == 0` なら `n` は2のべき乗（1ビットのみ）
