# Counting Bits (Easy)

## 問題内容

整数 `n` が与えられる。`0` から `n` までの各数について、その2進数表現における `1` のビット数をカウントする。

結果を配列 `output` として返す。`output[i]` は `i` の2進数表現における `1` の数。

### 例

```
Input: n = 4

Output: [0,1,1,2,1]
```

説明:
- 0 --> 0 (1が0個)
- 1 --> 1 (1が1個)
- 2 --> 10 (1が1個)
- 3 --> 11 (1が2個)
- 4 --> 100 (1が1個)

### 制約

- `0 <= n <= 1000`

## ソースコード

```go
func countBits(n int) []int {
    dp := make([]int, n+1)
    offset := 1

    for i := 1; i <= n; i++ {
        if offset*2 == i {
            offset = i
        }
        dp[i] = 1 + dp[i-offset]
    }

    return dp
}
```

## アルゴリズムなど解説

### 基本戦略（DP + オフセット）

**重要な観察**: 2進数のパターンは2のべき乗ごとに繰り返す

```
0:  0    offset=1
1:  1    = 1 + dp[0]
---
2:  10   offset=2
3:  11   = 1 + dp[1]
---
4:  100  offset=4
5:  101  = 1 + dp[1]
6:  110  = 1 + dp[2]
7:  111  = 1 + dp[3]
```

`i` のビット数 = 1 + `(i - 最も近い2のべき乗)` のビット数

### 動作の仕組み

```go
func countBits(n int) []int {
    dp := make([]int, n+1)
    offset := 1  // 現在の2のべき乗

    for i := 1; i <= n; i++ {
        if offset*2 == i {
            offset = i  // 次の2のべき乗に更新
        }
        dp[i] = 1 + dp[i-offset]
    }

    return dp
}
```

### 具体例

```
n = 5 の場合:

i=1: offset=1, dp[1] = 1 + dp[0] = 1
i=2: offset=2, dp[2] = 1 + dp[0] = 1
i=3: offset=2, dp[3] = 1 + dp[1] = 2
i=4: offset=4, dp[4] = 1 + dp[0] = 1
i=5: offset=4, dp[5] = 1 + dp[1] = 2

結果: [0,1,1,2,1,2]
```

### なぜこの式が成り立つか

任意の数 `i` は次のように表せる：
```
i = 2^k + remainder  (2^k は i 以下の最大の2のべき乗)
```

`2^k` は1ビットのみなので、`i` のビット数は：
```
bits(i) = 1 + bits(remainder) = 1 + bits(i - 2^k)
```

### 計算量

| 計算量 | 値 | 説明 |
|--------|-----|------|
| 時間計算量 | O(n) | 各数を1回処理 |
| 空間計算量 | O(n) | 出力配列 |

### 別解：右シフト + 最下位ビット

```go
func countBits(n int) []int {
    dp := make([]int, n+1)
    for i := 1; i <= n; i++ {
        dp[i] = dp[i>>1] + (i & 1)
    }
    return dp
}
```

**この式の意味**:
- `i >> 1`: i を右に1ビットシフト（2で割る）
- `i & 1`: 最下位ビットが1かどうか
- `bits(i) = bits(i/2) + (最下位ビット)`

### 具体例（別解）

```
i=5 (101):
  i>>1 = 2 (10)
  i&1 = 1
  dp[5] = dp[2] + 1 = 1 + 1 = 2 ✓
```

### 2つの解法の比較

| 解法 | 時間計算量 | 空間計算量 | 特徴 |
|------|------------|------------|------|
| オフセット法 | O(n) | O(n) | 2のべき乗パターンを利用 |
| 右シフト法 | O(n) | O(n) | よりシンプル |

### Bit Manipulation パターン

この問題は **DP + ビット** パターン：
- 以前の結果を再利用
- ビットパターンの周期性
- O(n) で全ての値を計算

### 関連問題との比較

| 問題 | パターン |
|------|---------|
| Number of 1 Bits | 単一の数のハミング重み |
| **Counting Bits** | 0〜nの各ハミング重み |
| Reverse Bits | ビット反転 |
| Missing Number | XOR応用 |
