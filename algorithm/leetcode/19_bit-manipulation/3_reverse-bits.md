# Reverse Bits (Easy)

## 問題内容

32ビット符号なし整数 `n` が与えられる。`n` の2進数表現のビットを反転し、結果を返す。

### 例

```
Input: n = 00000000000000000000000000010101

Output: 2818572288 (10101000000000000000000000000000)
```

説明: `00000000000000000000000000010101`（符号なし整数21）を反転すると `10101000000000000000000000000000`（符号なし整数2818572288）になる。

### 制約

- 入力は32ビット符号なし整数

## ソースコード

```go
func reverseBits(n int) int {
    res := 0
    for i := 0; i < 32; i++ {
        bit := (n >> i) & 1
        res += bit << (31 - i)
    }
    return res
}
```

## アルゴリズムなど解説

### 基本戦略

**発想**: 位置 `i` のビットを位置 `31-i` に移動

32ビットすべてについて：
1. 元の位置からビットを抽出
2. 反転後の位置にビットを配置
3. 結果に加算

### 動作の仕組み

```go
func reverseBits(n int) int {
    res := 0
    for i := 0; i < 32; i++ {
        bit := (n >> i) & 1       // 位置iのビットを抽出
        res += bit << (31 - i)    // 位置31-iに配置
    }
    return res
}
```

### 具体例

```
n = 21 (00000000000000000000000000010101)

i=0: bit=1, 位置31に配置 → 10000000000000000000000000000000
i=2: bit=1, 位置29に配置 → 10100000000000000000000000000000
i=4: bit=1, 位置27に配置 → 10101000000000000000000000000000

結果: 2818572288
```

### ビット操作の詳細

1. **ビット抽出**: `(n >> i) & 1`
   - `n` を右に `i` ビットシフト
   - `& 1` で最下位ビットのみ取得

2. **ビット配置**: `bit << (31 - i)`
   - ビットを左に `31-i` シフト
   - 反転後の正しい位置に移動

### 計算量

| 計算量 | 値 | 説明 |
|--------|-----|------|
| 時間計算量 | O(1) | 32回の固定ループ |
| 空間計算量 | O(1) | 定数空間 |

### 別解：分割統治法

```go
func reverseBits(n uint32) uint32 {
    res := n
    res = (res >> 16) | (res << 16)
    res = ((res & 0xff00ff00) >> 8) | ((res & 0x00ff00ff) << 8)
    res = ((res & 0xf0f0f0f0) >> 4) | ((res & 0x0f0f0f0f) << 4)
    res = ((res & 0xcccccccc) >> 2) | ((res & 0x33333333) << 2)
    res = ((res & 0xaaaaaaaa) >> 1) | ((res & 0x55555555) << 1)
    return res
}
```

**分割統治の考え方**:
1. 16ビットずつ入れ替え
2. 8ビットずつ入れ替え
3. 4ビットずつ入れ替え
4. 2ビットずつ入れ替え
5. 1ビットずつ入れ替え

### 分割統治の具体例

```
元:     ABCDEFGH (8ビット簡略版)

16bit:  EFGHABCD
8bit:   GHEFCDAB
4bit:   HGFEDCBA ✓
```

### 2つの解法の比較

| 解法 | 時間計算量 | ループ回数 | 特徴 |
|------|------------|------------|------|
| ビットごと | O(1) | 32回 | 直感的 |
| 分割統治 | O(1) | 5回 | 高速だが複雑 |

### マスクの意味

```
0xaaaaaaaa = 10101010... (奇数位置)
0x55555555 = 01010101... (偶数位置)
0xcccccccc = 11001100... (2ビットペア上位)
0x33333333 = 00110011... (2ビットペア下位)
0xf0f0f0f0 = 11110000... (4ビット上位)
0x0f0f0f0f = 00001111... (4ビット下位)
```

### Bit Manipulation パターン

この問題は **ビット反転** パターン：
- 位置変換: `i → 31-i`
- マスクを使った部分抽出
- 分割統治による高速化

### 関連問題との比較

| 問題 | パターン |
|------|---------|
| Number of 1 Bits | ビット数カウント |
| Counting Bits | 0〜nのビット数 |
| **Reverse Bits** | ビット順反転 |
| Reverse Integer | 10進数反転 |
