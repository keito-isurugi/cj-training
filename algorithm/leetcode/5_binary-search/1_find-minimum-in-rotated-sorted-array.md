# Find Minimum in Rotated Sorted Array (Medium)

## 問題内容

長さ `n` の昇順ソート済み配列が1〜n回回転されている。この配列の最小要素を返す。

回転の例: `nums = [1,2,3,4,5,6]` の場合
- 4回回転 → `[3,4,5,6,1,2]`
- 6回回転 → `[1,2,3,4,5,6]`（元に戻る）

O(n)の解法は自明だが、O(log n)で解くことが求められる。

### 例

```
Input: nums = [3,4,5,6,1,2]
Output: 1

Input: nums = [4,5,0,1,2,3]
Output: 0

Input: nums = [4,5,6,7]
Output: 4
```

### 制約

- `1 <= nums.length <= 1000`
- `-1000 <= nums[i] <= 1000`
- すべての要素はユニーク

## ソースコード

```go
func findMin(nums []int) int {
    l, r := 0, len(nums)-1
    for l < r {
        m := l + (r-l)/2
        if nums[m] < nums[r] {
            r = m
        } else {
            l = m + 1
        }
    }
    return nums[l]
}
```

## アルゴリズムなど解説

### 基本戦略

Binary Searchを使って、回転点（最小値の位置）を探す。

### 回転配列の特性

```
元の配列: [1, 2, 3, 4, 5, 6]
回転後:   [3, 4, 5, 6, 1, 2]
                    ↑
                  回転点（最小値）

特性:
- 回転点より左: 大きい値のソート済み部分
- 回転点より右: 小さい値のソート済み部分
- nums[回転点] < nums[r] は常に成立
```

### 動作の仕組み

1. **中央値と右端を比較**
   ```go
   if nums[m] < nums[r] {
       r = m      // 最小値はm以下にある
   } else {
       l = m + 1  // 最小値はmより右にある
   }
   ```

2. **なぜ `nums[r]` と比較するのか**
   ```
   [3, 4, 5, 6, 1, 2]
              m     r

   nums[m]=6 > nums[r]=2
   → mは回転点より左側にいる
   → 最小値はmより右にある
   → l = m + 1

   [3, 4, 5, 6, 1, 2]
    l        m     r

   nums[m]=1 < nums[r]=2
   → mは回転点以下にいる
   → 最小値はm以下にある
   → r = m（mを含める）
   ```

### 具体例: `nums = [3,4,5,6,1,2]`

```
初期: l=0, r=5

ステップ1:
[3, 4, 5, 6, 1, 2]
 l        m     r

m = (0+5)/2 = 2
nums[m]=5 > nums[r]=2
→ l = m + 1 = 3

ステップ2:
[3, 4, 5, 6, 1, 2]
          l  m  r

m = (3+5)/2 = 4
nums[m]=1 < nums[r]=2
→ r = m = 4

ステップ3:
[3, 4, 5, 6, 1, 2]
          l  r
          m

m = (3+4)/2 = 3
nums[m]=6 > nums[r]=1
→ l = m + 1 = 4

ステップ4:
l == r == 4
ループ終了

return nums[4] = 1 ✓
```

### 回転がない場合: `nums = [4,5,6,7]`

```
初期: l=0, r=3

ステップ1:
[4, 5, 6, 7]
 l     m  r

m = 1
nums[m]=5 < nums[r]=7
→ r = m = 1

ステップ2:
[4, 5, 6, 7]
 l  r
 m

m = 0
nums[m]=4 < nums[r]=5
→ r = m = 0

l == r == 0
return nums[0] = 4 ✓
```

### なぜ `l = m + 1` で `r = m` なのか

```
r = m にする理由:
- nums[m] < nums[r] のとき、mが最小値の可能性がある
- mを除外すると最小値を見逃す

l = m + 1 にする理由:
- nums[m] > nums[r] のとき、mは絶対に最小値ではない
- mより右に必ず小さい値がある
```

### 計算量

| 計算量 | 値 | 説明 |
|--------|-----|------|
| 時間計算量 | O(log n) | Binary Searchで毎回半分に絞る |
| 空間計算量 | O(1) | ポインタのみ使用 |
