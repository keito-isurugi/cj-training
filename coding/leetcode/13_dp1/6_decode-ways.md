# Decode Ways (Medium)

## 問題内容

大文字の英字で構成される文字列は、以下のマッピングを使用して数字にエンコードできる：

```
'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
```

メッセージを**デコード**するには、数字をグループ化して文字にマッピングし直す必要がある。デコードには複数の方法がある場合がある。例えば、`"1012"` は以下のようにマッピングできる：

- `"JAB"` （グループ化: `(10 1 2)`）
- `"JL"` （グループ化: `(10 12)`）

グループ化 `(1 01 2)` は無効。`01` は先頭がゼロのため文字にマッピングできない。

数字のみを含む文字列 `s` が与えられたとき、**デコードする方法の数**を返す。答えは**32ビット**整数に収まると仮定してよい。

### 例

```
Input: s = "12"
Output: 2
```
説明: "12" は "AB" (1 2) または "L" (12) としてデコードできる。

```
Input: s = "01"
Output: 0
```
説明: "01" はデコードできない。"01" は先頭ゼロのため文字にマッピングできない。

### 制約

- `1 <= s.length <= 100`
- `s` は数字のみを含む

## ソースコード

```go
func numDecodings(s string) int {
    n := len(s)
    dp := make([]int, n+1)
    dp[n] = 1

    for i := n - 1; i >= 0; i-- {
        if s[i] == '0' {
            dp[i] = 0
        } else {
            dp[i] = dp[i+1]
            if i+1 < n && (s[i] == '1' || (s[i] == '2' && s[i+1] <= '6')) {
                dp[i] += dp[i+2]
            }
        }
    }

    return dp[0]
}
```

## アルゴリズムなど解説

### 基本戦略

各インデックス `i` で、**2つのデコード選択肢**がある：
1. **1桁**をデコード（`s[i]` → 1〜9 は有効）
2. **2桁**をデコード（`s[i:i+2]` → 10〜26 は有効）

これは Climbing Stairs に似たフィボナッチ型の問題。

### 核心となる洞察

```
dp[i] = dp[i+1] + dp[i+2]（条件付き）
```

ただし：
- `s[i] == '0'` の場合、`dp[i] = 0`（先頭ゼロは無効）
- 2桁デコードは 10〜26 の範囲のみ有効

### 動作の仕組み

1. **後ろから前へ計算**
   ```go
   dp[n] = 1  // 基本ケース：空文字列は1通り
   for i := n - 1; i >= 0; i-- {
       // ...
   }
   ```

2. **先頭ゼロチェック**
   ```go
   if s[i] == '0' {
       dp[i] = 0
   }
   ```
   - '0' で始まる部分文字列はデコード不可

3. **1桁デコード**
   ```go
   dp[i] = dp[i+1]
   ```
   - 1〜9 は常に有効

4. **2桁デコード**
   ```go
   if i+1 < n && (s[i] == '1' || (s[i] == '2' && s[i+1] <= '6')) {
       dp[i] += dp[i+2]
   }
   ```
   - 10〜19 または 20〜26 の場合のみ有効

### 具体例

```
s = "226"

dp[3] = 1 (空文字列)

i=2 ('6'):
  '6' != '0' → dp[2] = dp[3] = 1
  2桁: "6?" → なし

i=1 ('2'):
  '2' != '0' → dp[1] = dp[2] = 1
  2桁: "26" → 有効 → dp[1] += dp[3] = 2

i=0 ('2'):
  '2' != '0' → dp[0] = dp[1] = 2
  2桁: "22" → 有効 → dp[0] += dp[2] = 3

結果: 3
デコード方法: "BZ", "VF", "BBF"
```

### 計算量

| 計算量 | 値 | 説明 |
|--------|-----|------|
| 時間計算量 | O(n) | 各文字を1回処理 |
| 空間計算量 | O(n) | DP配列 |

### 別解：空間最適化

```go
func numDecodings(s string) int {
    n := len(s)
    next, nextNext := 1, 0

    for i := n - 1; i >= 0; i-- {
        curr := 0
        if s[i] != '0' {
            curr = next
            if i+1 < n && (s[i] == '1' || (s[i] == '2' && s[i+1] <= '6')) {
                curr += nextNext
            }
        }
        nextNext = next
        next = curr
    }

    return next
}
```

**空間最適化のアイデア**：
- `dp[i]` は `dp[i+1]` と `dp[i+2]` にのみ依存
- 2つの変数で十分（O(1) 空間）

### 別解：再帰 + メモ化

```go
func numDecodings(s string) int {
    memo := make(map[int]int)
    memo[len(s)] = 1

    var dfs func(i int) int
    dfs = func(i int) int {
        if val, ok := memo[i]; ok {
            return val
        }
        if s[i] == '0' {
            return 0
        }

        res := dfs(i + 1)
        if i+1 < len(s) && (s[i] == '1' || (s[i] == '2' && s[i+1] <= '6')) {
            res += dfs(i + 2)
        }
        memo[i] = res
        return res
    }

    return dfs(0)
}
```

### 無効なケース

| ケース | 例 | 結果 |
|--------|-----|------|
| 先頭ゼロ | "01" | 0 |
| 途中のゼロ | "10" | 1 ("J") |
| 27以上の2桁 | "27" | 1 ("BG") |
| 連続ゼロ | "100" | 0 |

### DPパターン

この問題は **条件付きフィボナッチ型DP** パターン：
- 基本は `dp[i] = dp[i+1] + dp[i+2]`
- 先頭ゼロと範囲チェックの条件が追加
- Climbing Stairs の応用問題

### 関連問題との比較

| 問題 | 選択肢 | 条件 |
|------|--------|------|
| Climbing Stairs | 1歩 or 2歩 | なし |
| **Decode Ways** | 1桁 or 2桁 | 有効な文字のみ |
| Decode Ways II | 1桁 or 2桁 | ワイルドカード '*' あり |
