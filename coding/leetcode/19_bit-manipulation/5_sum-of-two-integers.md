# Sum of Two Integers (Medium)

## 問題内容

2つの整数 `a` と `b` が与えられる。`+` 演算子と `-` 演算子を使わずに、2つの整数の和を返す。

### 例

```
Input: a = 1, b = 1

Output: 2
```

```
Input: a = 4, b = 7

Output: 11
```

### 制約

- `-1000 <= a, b <= 1000`

## ソースコード

```go
func getSum(a int, b int) int {
    var add func(x, y int) int
    add = func(x, y int) int {
        if x == 0 || y == 0 {
            if x != 0 {
                return x
            }
            return y
        }
        return add(x^y, (x&y)<<1)
    }

    if a*b < 0 {
        if a > 0 {
            return getSum(b, a)
        }
        if add(^a, 1) == b {
            return 0
        }
        if add(^a, 1) < b {
            return add(^(add(add(^a, 1), add(^b, 1))), 1)
        }
    }

    return add(a, b)
}
```

## アルゴリズムなど解説

### 基本戦略（ビット演算による加算）

**2進数の加算は2つの操作**:
1. **XOR (`^`)**: 繰り上がりなしの和
2. **AND + 左シフト (`& << 1`)**: 繰り上がり

```
1 + 1 = 10 (2進数)
  XOR:  1 ^ 1 = 0  (繰り上がりなしの和)
  Carry: (1 & 1) << 1 = 10 (繰り上がり)
  合計: 0 + 10 = 10 ✓
```

### 動作の仕組み

```go
func add(x, y int) int {
    if x == 0 || y == 0 {
        return x | y  // どちらかが0なら他方を返す
    }
    return add(x^y, (x&y)<<1)  // 和と繰り上がりで再帰
}
```

### 具体例

```
a = 5 (101), b = 3 (011)

ステップ1:
  sum = 5 ^ 3 = 110 (6)
  carry = (5 & 3) << 1 = 001 << 1 = 010 (2)

ステップ2:
  sum = 6 ^ 2 = 100 (4)
  carry = (6 & 2) << 1 = 010 << 1 = 100 (4)

ステップ3:
  sum = 4 ^ 4 = 000 (0)
  carry = (4 & 4) << 1 = 100 << 1 = 1000 (8)

ステップ4:
  sum = 0 ^ 8 = 8
  carry = 0

結果: 8 ✓ (5 + 3 = 8)
```

### 繰り上がりがなくなるまで繰り返す

```
while b != 0:
    carry = (a & b) << 1
    a = a ^ b
    b = carry
return a
```

繰り上がり `b` が0になったら、`a` が最終結果。

### 計算量

| 計算量 | 値 | 説明 |
|--------|-----|------|
| 時間計算量 | O(1) | 最大32回のループ |
| 空間計算量 | O(1) | 定数空間 |

### 負の数の処理（Go言語の場合）

Go言語では負の数を扱う場合、2の補数表現に注意が必要。

```go
if a*b < 0 {  // 符号が異なる場合
    // 特別な処理
}
```

### シンプルな反復版（正の数向け）

```go
func getSum(a int, b int) int {
    for b != 0 {
        carry := (a & b) << 1
        a = a ^ b
        b = carry
    }
    return a
}
```

### ビット演算の対応表

| 演算 | ビット操作 | 説明 |
|------|-----------|------|
| 加算 | `a ^ b` + carry | XOR + 繰り上がり |
| 減算 | `a + (~b + 1)` | 2の補数を加算 |
| 否定 | `~a + 1` | ビット反転 + 1 |

### なぜこれが動くか

半加算器の回路と同じ原理：
- **Sum bit**: `a XOR b`
- **Carry bit**: `a AND b`

全加算器は半加算器を2つ組み合わせ、前の桁からの繰り上がりを処理。

### Bit Manipulation パターン

この問題は **ビット演算による算術** パターン：
- XORで繰り上がりなしの和
- ANDで繰り上がり位置を検出
- 左シフトで繰り上がりを次の桁へ

### 関連問題との比較

| 問題 | パターン |
|------|---------|
| **Sum of Two Integers** | ビット演算で加算 |
| Divide Two Integers | ビット演算で除算 |
| Multiply Strings | 文字列で乗算 |
| Add Binary | 2進数文字列の加算 |

### 発展

この原理は：
- CPUの加算回路の基礎
- ハードウェア設計の基本
- 並列計算の理解に役立つ
